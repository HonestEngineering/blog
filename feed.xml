<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="https://honest.engineering/feed.xml" rel="self" type="application/atom+xml" /><link href="https://honest.engineering/" rel="alternate" type="text/html" /><updated>2018-10-27T13:17:18+00:00</updated><id>https://honest.engineering/</id><title type="html">Honest Engineering</title><subtitle>We are a group of fellow engineers who want to share an honest vision of the current state of web engineering. Most of articles are either self promotions, or too opinionated. We want to share honest and unbiased thought about the current state of tech. Our mission is to help fellow engineers forge their own opinion on current trendy and controversial subjects.</subtitle><entry><title type="html">Hash Functions survival guide</title><link href="https://honest.engineering/posts/hash-functions-survival-guide" rel="alternate" type="text/html" title="Hash Functions survival guide" /><published>2018-10-20T14:03:00+00:00</published><updated>2018-10-20T14:03:00+00:00</updated><id>https://honest.engineering/posts/hash-functions-survival-guide</id><content type="html" xml:base="https://honest.engineering/posts/hash-functions-survival-guide">&lt;p&gt;Hash functions are one of the building blocks behind robust solutions to solve architectural problems every developer will encounter in their career, like how to securely store passwords or how to distribute work across many servers.&lt;/p&gt;

&lt;p&gt;To be honest, while their concepts are well known, they can also easily be misused.&lt;/p&gt;

&lt;p&gt;This article hopes to shed some light on how to safely leverage them for some standard use-cases.&lt;/p&gt;

&lt;h3 id=&quot;a-note-on-terminology&quot;&gt;A note on Terminology&lt;/h3&gt;
&lt;p&gt;Depending on your community or programming language of choice, you may know some constructs and applications under different terms.&lt;/p&gt;

&lt;p&gt;This article will use the following nomenclature:&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;hash function&lt;/em&gt; refers to the implementation in which, given an arbitrary input, returns a deterministic output&lt;/p&gt;

&lt;p&gt;This function implements a &lt;em&gt;hash algorithm&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;hash&lt;/em&gt; (which you may know as a &lt;em&gt;digest&lt;/em&gt; or &lt;em&gt;hash code&lt;/em&gt;) refers to the function’s output&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://honest.engineering/assets/tips-hash-1.png&quot; alt=&quot;A hash functions implements a hash algorithm to generate a hash code&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;do--know-how-a-hash-function-work&quot;&gt;Do : know how a hash function work&lt;/h2&gt;

&lt;p&gt;A hash function is a deterministic function in which, given an arbitrary large input, returns a deterministic, fixed-size output. E.g, the &lt;a href=&quot;https://en.wikipedia.org/wiki/MurmurHash#Algorithm&quot;&gt;MurmurHash3 function&lt;/a&gt;, in its 32 bits variant, will map any input to a 32 bit hash code :&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Input&lt;/th&gt;
      &lt;th&gt;Input size&lt;/th&gt;
      &lt;th&gt;Output&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;The “foo” ASCII string&lt;/td&gt;
      &lt;td&gt;3B&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x1764df7f&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;The entire &lt;a href=&quot;https://gist.github.com/provpup/2fc41686eab7400b796b&quot;&gt;Hamlet&lt;/a&gt; play&lt;/td&gt;
      &lt;td&gt;188kB&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x2b881d54&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;The &lt;a href=&quot;https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png&quot;&gt;lenna&lt;/a&gt; test image&lt;/td&gt;
      &lt;td&gt;468kB&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x001fad14&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This implies that an infinite input space is mapped to a finite number of outputs. Therefore, there must be some inputs which return the same hash code. These are known as &lt;strong&gt;collisions&lt;/strong&gt;. Most use cases leverage the pseudo-uniqueness of hash codes, so you want to avoid them.&lt;/p&gt;

&lt;p&gt;Since a function which always returns 42 can be considered a hash function under these terms, industrial-use hash algorithms are expected to meet the following criteria :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Uniformity&lt;/strong&gt; : Their output should be evenly distributed into the output space. E.g, still using the MurmurHash3 as an example :&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Input (ASCII String)&lt;/th&gt;
          &lt;th&gt;Output (32bit unsigned int)&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;foo&lt;/td&gt;
          &lt;td&gt;4138058784&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;fou&lt;/td&gt;
          &lt;td&gt;2660153266&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;boo&lt;/td&gt;
          &lt;td&gt;389335901&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Determinism&lt;/strong&gt; : Given an input, the hash function shall always return the same output&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Each algorithm has a given length, which refers to the number of bits of the hash codes it generates. E.g, SHA-256 generate 256 bits hash codes, and murmur3 can be configured to generate 32 bits or 128 bits hash codes. Generally, short hashes are faster to generate, and lighter to manipulate, but have a greater collision risk.&lt;/p&gt;

&lt;h2 id=&quot;do--know-the-difference-between-crypto-and-non-crypto-hash-algorithms&quot;&gt;Do : know the difference between crypto and non-crypto hash algorithms&lt;/h2&gt;

&lt;p&gt;A subset of hash algorithms can be considered &lt;strong&gt;cryptographic hash algorithms&lt;/strong&gt;, if they meet these additional criteria :&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Preimage resistance&lt;/strong&gt; : Given a hash code, it should be hard to generate a message having the same hash code&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Second-preimage resistance&lt;/strong&gt; : Given a message, it should be hard to find a second message having the same hash code&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Collision resistance&lt;/strong&gt; : It should be hard to find two distinct messages having the same hash code&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By “hard”, we mean that brute forcing all inputs should be the fastest approach.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;SHA-2&lt;/strong&gt; family are a widely-implemented and respected collection of cryptographic hash algorithms. When in doubt, they should not be a bad choice. MD5 and SHA-1 should be avoided, as their collision resistance has been broken by the advancement of computation speed.&lt;/p&gt;

&lt;p&gt;Concerning &lt;strong&gt;non-crypto hashes&lt;/strong&gt;, your language of choice should already have an existing implementation (e.g : ruby has Object#hash, based on the murmur2 algorithm). If that is the case, &lt;strong&gt;trust it and use it&lt;/strong&gt;. More than the implementation, you want to leverage the years of optimization work on multiple hardware architectures.&lt;/p&gt;

&lt;p&gt;If your language does not have a native implementation of a good non-crypto hash algorithm, you may use one of the following ones :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Murmur3&lt;/li&gt;
  &lt;li&gt;FNV Hash&lt;/li&gt;
  &lt;li&gt;CityHash&lt;/li&gt;
  &lt;li&gt;xxHash&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dont--roll-your-own-implementations&quot;&gt;Don’t : roll your own implementations&lt;/h2&gt;

&lt;p&gt;This article will reference some well known and standard hash algorithms.
While these algorithm are open, you should avoid reimplementing them, and try to use existing implementations :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Standard hash algorithms are likely to have been optimized down to the hardware level&lt;/li&gt;
  &lt;li&gt;Crypto algorithms have been audited by people way smarter than you or me&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If your platform does not come with native implementations, &lt;a href=&quot;https://download.libsodium.org/doc/&quot;&gt;libsodium&lt;/a&gt; is a very well made library which contains all the functions you may need.&lt;/p&gt;

&lt;h2 id=&quot;dont--use-a-crypto-hash-algorithm-for-non-sensitive-uses&quot;&gt;Don’t : use a crypto hash algorithm for non-sensitive uses&lt;/h2&gt;

&lt;p&gt;Crypto or non-crypto, every good hash function gives you a strong uniformity guarantee. Crypto hashes are however slower, and tend to generate larger codes (256 bits or more)&lt;/p&gt;

&lt;p&gt;Using them to implement a bucketing strategy for 100 servers would be over-engineering. Just use a simple, fast, non-crypto algorithm for it.&lt;/p&gt;

&lt;h2 id=&quot;do--use-the-right-encoding-for-your-use-case&quot;&gt;Do : use the right encoding for your use case&lt;/h2&gt;

&lt;p&gt;Hash functions typically return binary hash codes.&lt;/p&gt;

&lt;p&gt;Depending on your use case, you should know which encoding is better suited for a use case.&lt;/p&gt;

&lt;p&gt;For example, the hash code of the ASCII string “foo” can be encoded as :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A &lt;strong&gt;uint32&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;4138058784&lt;/code&gt; easy to modulo for bucketing&lt;/li&gt;
  &lt;li&gt;A &lt;strong&gt;hex code&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;0xf6a5c420&lt;/code&gt; for machine-to-machine exchange&lt;/li&gt;
  &lt;li&gt;A &lt;strong&gt;binary code&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;0bx11110110101001011100010000100000&lt;/code&gt; for storage&lt;/li&gt;
  &lt;li&gt;A &lt;strong&gt;Base64 code&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;IMSl9g&lt;/code&gt; for lightweight HTTP transfer&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;do--leverage-hashes-for-bucketing&quot;&gt;Do : leverage hashes for bucketing&lt;/h2&gt;

&lt;p&gt;The most well known application of hash functions are &lt;strong&gt;hash tables&lt;/strong&gt;. A hash table is a data structure mapping keys to value, enabling fast data lookup by partitioning its values into a select number of &lt;strong&gt;buckets&lt;/strong&gt;. The hash code of the key can be transformed into a deterministic bucket index in constant time. You’re effectively trading a small constant hash computation cost for a 0(1) lookup complexity.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://honest.engineering/assets/tips-hash-2.png&quot; alt=&quot;Sample hash table algorithm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The cool property of hash tables is that they ensure a good data repartition without any pre-existing knowledge of the data going into it. You can use the same approach for any &lt;strong&gt;deterministic stateless pseudo-random attribution&lt;/strong&gt; : e.g balancing jobs on workers, payloads on servers, or riders on drivers.&lt;/p&gt;

&lt;h2 id=&quot;dont--use-a-naive-bucketing-strategy-for-a-variable-amount-of-buckets&quot;&gt;Don’t : use a naive bucketing strategy for a variable amount of buckets&lt;/h2&gt;

&lt;p&gt;A standard bucketing strategy consists of modulo-ing the data hash code with the number of buckets. As the hash function is uniform, this guarantees an eventual uniform repartition of resources between the buckets.&lt;/p&gt;

&lt;p&gt;This strategy is not robust when faced with a varying amount of buckets, especially when migration costs are high, like in distributed hash tables. When having N buckets, adding or removing one means that almost all the data needs to be redistributed between the buckets.&lt;/p&gt;

&lt;p&gt;Using a division instead of a modulo is better, but still implies that all buckets need to reallocate data.&lt;/p&gt;

&lt;p&gt;The right solution for this is using &lt;a href=&quot;https://en.wikipedia.org/wiki/Consistent_hashing&quot;&gt;consistent hashing&lt;/a&gt;. While this diminishes the uniformity of the data repartition, you gain the guarantee that adding / removing a bucket means that only one bucket needs to have its data migrated.&lt;/p&gt;

&lt;h2 id=&quot;dont--use-a-raw-hash-for-message-signing&quot;&gt;Don’t : use a raw hash for message signing&lt;/h2&gt;

&lt;p&gt;Another common use of hash functions is for message signing. This can done using a hash-based message authentication code, or &lt;strong&gt;HMAC&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;While a cryptographic hash function can assert the integrity of a message (i.e the message has not been tampered with during transfer), a HMAC also asserts its authenticity (i.e the messages comes from the sender). This mechanism is enabled via a shared secret key between the sender and the recipient.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://honest.engineering/assets/tips-hash-3.png&quot; alt=&quot;HMAC uses a key as a parameter for digest generation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At first glance, transmitting the hash of a concatenation of the message and the secret key may seem to do the same job.&lt;/p&gt;

&lt;p&gt;However, many hash algorithms, including SHA-2, are vulnerable against length extension attacks (meaning that - knowing the hash code and message length - it is possible to generate data which when appended to the message will keep the hash code valid).&lt;/p&gt;

&lt;p&gt;The HMAC algorithm provides immunity against this kind of attacks. Its design makes it secure even when used with insecure hash functions (MD5 or SHA-1).&lt;/p&gt;

&lt;p&gt;In short, when you need a stateless way to validate that a payload comes from a trusted sender, and has not been tampered with, send a HMAC-SHA2 code alongside it. If you want to protect yourself against replay attacks, it is as easy as including a timestamp in the payload.&lt;/p&gt;

&lt;p&gt;Common use cases in the wild include API authentication (e.g AWS) and JSON web tokens.&lt;/p&gt;

&lt;h2 id=&quot;dont--use-sha-for-password-hashes&quot;&gt;Don’t : use SHA for password hashes&lt;/h2&gt;

&lt;p&gt;Storing passwords in clear text is evil. While security best practices and password managers are on the rise, the vast majority of users reuse their passwords on multiple services. It is your duty to ensure that, in the event your database is comprised, the impact on your users is limited.&lt;/p&gt;

&lt;p&gt;At a minimum, the passwords you store should be&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cryptographically hashed (so while you can easily verify a match, the original plaintext one is not deducible from the hash)&lt;/li&gt;
  &lt;li&gt;Salted (in order to be robust against rainbow table attacks)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While these practices are not bad per-ser, a standard hash function won’t do. Hash algorithms, even cryptographic ones, are so ubiquitous in today’s tech that their implementation must be &lt;strong&gt;fast&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Since your adversary knows both the hash and salt, and can with his GPU compute a billions SHA-256 hash codes per second, you have to use a hash function specifically &lt;strong&gt;designed to be slow&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;You should use&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Argon2&lt;/em&gt; : the most recent one, winner of the 2015 password hashing competition&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;BCrypt&lt;/em&gt; : an older one, more vulnerable to hardware-optimize attacks, but more vetted and maybe already part of your standard library&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In short, when storing passwords, generate a secure and long hash, hash it with a slow hash function, and store only the hash and the salt.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We hope these tips helped expand your knowledge of what hash functions can and cannot do. Hopefully you won’t make the same mistakes we did before learning these.&lt;/p&gt;

&lt;p&gt;This article is only scratching the surface of the subject. Security is a complicated field, and there are still some debate in the community on certain points (e.g whether you should use SHA-3 or not).&lt;/p&gt;

&lt;p&gt;If you wish to dig deeper, there are resources on the &lt;a href=&quot;https://security.stackexchange.com&quot;&gt;security&lt;/a&gt; and &lt;a href=&quot;https://crypto.stackexchange.com.&quot;&gt;crypto&lt;/a&gt; stackexchanges.&lt;/p&gt;

&lt;h3 id=&quot;more-resources&quot;&gt;More resources&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://security.stackexchange.com/questions/211/how-to-securely-hash-passwords/31846#31846&quot;&gt;Comparison of password hashing algorithms&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://crackstation.net/hashing-security.htm&quot;&gt;Why / how should you hash passwords&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://download.libsodium.org/doc/&quot;&gt;The libsodium crypto primitives&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.toptal.com/big-data/consistent-hashing&quot;&gt;A guide to consistent hashing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blueprintinteractive.com/blog/securing-your-api-hmac-authentication&quot;&gt;A guide to HMAC API authentication&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hackernoon.com/probabilistic-data-structures-bloom-filter-5374112a7832&quot;&gt;An introduction to bloom filters&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://csrc.nist.gov/Projects/Hash-Functions/NIST-Policy-on-Hash-Functions&quot;&gt;The current NIST policy on hash functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;style&gt;
  h2 {
    margin-top: 3em;
  }
  h3 {
    margin-top: 2em;
  }
  table {
    width: 100%;
    border: 1px solid #cbcbcb;
    border-collapse: collapse;
    border-spacing: 0;
    margin: 1.5em 0em;
  }
  thead {
    background-color: #e0e0e0;
    color: #000;
    text-align: left;
    vertical-align: bottom;
  }
  td:first-child,  th:first-child {
    border-left-width: 0;
  }
  td, th {
    border-left: 1px solid #cbcbcb;
    border-width: 0 0 0 1px;
    font-size: inherit;
    margin: 0;
    overflow: visible;
    padding: .5em 1em;
  }
&lt;/style&gt;</content><author><name></name></author><category term="Tips" /><summary type="html">Hash functions are one of the building blocks behind robust solutions to solve architectural problems every developer will encounter in their career, like how to securely store passwords or how to distribute work across many servers.</summary></entry><entry><title type="html">Why use GraphQL, good and bad reasons</title><link href="https://honest.engineering/posts/why-use-graphql-good-and-bad-reasons" rel="alternate" type="text/html" title="Why use GraphQL, good and bad reasons" /><published>2018-08-04T10:59:40+00:00</published><updated>2018-08-04T10:59:40+00:00</updated><id>https://honest.engineering/posts/why-use-graphql-good-and-bad-reasons</id><content type="html" xml:base="https://honest.engineering/posts/why-use-graphql-good-and-bad-reasons">&lt;p&gt;To be honest, GraphQL had its dose of hype the last months.&lt;/p&gt;

&lt;p&gt;Went from “indie” to a “commercial” technology with company like &lt;a href=&quot;https://www.graph.cool/&quot;&gt;Prisma&lt;/a&gt;, &lt;a href=&quot;http://apollodata.com/optics/&quot;&gt;Apollo&lt;/a&gt; or even &lt;a href=&quot;https://aws.amazon.com/fr/appsync/&quot;&gt;Amazon&lt;/a&gt; providing professional products and support.&lt;/p&gt;

&lt;p&gt;As for &lt;a href=&quot;https://itnext.io/why-use-typescript-good-and-bad-reasons-ccd807b292fb&quot;&gt;TypeScript&lt;/a&gt; or any new technologies, comes the question:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Should I use this technology? Do I need it?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;If this question appeals to you, then this article is for you.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&quot;the-bad-reasons&quot;&gt;The bad reasons&lt;/h2&gt;

&lt;h3 id=&quot;graphql-is-a-trending-cool-technology&quot;&gt;GraphQL is a trending cool technology&lt;/h3&gt;

&lt;p&gt;Experienced developers know that we don’t use a technology because everybody uses it.&lt;/p&gt;

&lt;p&gt;Each technology has a purpose and solves one or many particular problems.&lt;/p&gt;

&lt;p&gt;Concerning GraphQL, the main goals of the project was to provide “A query language for your API”. Especially, allowing clients to specify what part of the data they need.&lt;/p&gt;

&lt;p&gt;This is pretty useful when considering mobile applications which have limited bandwidth and speed.&lt;/p&gt;

&lt;p&gt;You will see in the next “con” section that the cool GraphQL technology does not solve all issues neither for frontend or mobile side.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h3 id=&quot;graphql-solves-all-performance-issues&quot;&gt;GraphQL solves all performance issues&lt;/h3&gt;

&lt;p&gt;A GraphQL API (server) implementation, out of the box, will have better performance than a standard REST API - for the clients.&lt;/p&gt;

&lt;p&gt;Since resolvers are called in parallel, data will load faster.&lt;/p&gt;

&lt;p&gt;However, without resolvers optimisation, like joins, batch systems, your performance gain will not be that impressive - especially against a SQL database with a small pool size.&lt;/p&gt;

&lt;p&gt;Optimising resolvers performance can be complex since it depends on the use of your API.&lt;/p&gt;

&lt;p&gt;Dedicated tools like &lt;a href=&quot;https://www.apollographql.com/engine&quot;&gt;Apollo Engine&lt;/a&gt; will help you identify bottlenecks or your API’s most popular fields, but keep in mind that GraphQL will not magically improve your API performance.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h3 id=&quot;graphql-is-the-new-rest&quot;&gt;GraphQL is the new REST&lt;/h3&gt;

&lt;p&gt;GraphQL and REST are both very different things, GraphQL is a language and a technology, REST is an architecture pattern.&lt;/p&gt;

&lt;p&gt;Since they both introduced two different solutions, they can be complementary, and in short:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;GraphQL is not the end of REST.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Although GraphQL is very useful to solve complex data exchange, it is “over-engineered” to use it for simple or standard use cases.&lt;/p&gt;

&lt;p&gt;For example, microservices or non-user facing APIs, like APIs exposing data for Business Intelligence or other purposes has no need to provide heavy GraphQL API - after all REST is just HTTP with convention, so, simple to implement and use.&lt;/p&gt;

&lt;p&gt;We will see in the next “con” that GraphQL is not so present in ecosystems other that JavaScript.
Basically, GraphQL solves everything.&lt;/p&gt;

&lt;p&gt;First, as said in the previous section, GraphQL requires sending JSON to the API in order to get data.&lt;/p&gt;

&lt;p&gt;This can look dumb but, using GraphQL on the client side often requires to use a dedicated library to tackle the language complexity - that’s why we often talk about Apollo GraphQL rather than just GraphQL.&lt;/p&gt;

&lt;p&gt;That’s also why, compared to the simplicity of REST, you need to be sure that your problematics are linked to what GraphQL can solve (see “good reasons”).&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Secondly, as said in the second point, a GraphQL API server needs optimisations and maintenance.&lt;/p&gt;

&lt;p&gt;Making the graph-oriented way of getting data fit over an SQL database can be tricky.&lt;/p&gt;

&lt;p&gt;And, since it enables easier use on client side, GraphQL will directly move that responsibility to the server side.&lt;/p&gt;

&lt;p&gt;Now, the server has to deal with the client data queries and handle the complexity.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Finally, GraphQL is born from the JavaScript ecosystem.&lt;/p&gt;

&lt;p&gt;You will feel a real Developer Experience loss by using GraphQL outside a JavaScript ecosystem.
Let’s take the example of Ruby.&lt;/p&gt;

&lt;p&gt;Even if many people are deeply involved in its Ruby implementation by maintaining graphql-ruby or graphql-client, these involve using Threads and very declarative syntax (class/module based) - are you familiar with Thread safe programming in Ruby?&lt;/p&gt;

&lt;p&gt;Even in others languages or ecosystems, the edge of GraphQL resides in JavaScript and especially in the Apollo project.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&quot;the-good-reasons&quot;&gt;The good reasons&lt;/h2&gt;

&lt;h3 id=&quot;mobile-first-user-experience&quot;&gt;Mobile first User Experience&lt;/h3&gt;

&lt;p&gt;Definitely, GraphQL is a game changer for building rich UI/UX based mobile applications.&lt;/p&gt;

&lt;p&gt;Forget the “all-in-one” or preload REST endpoint and enjoy the force of GraphQL: loading what you need, when you need it, in a glance.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://honest.engineering/assets/REST-vs-GraphQL-example.png&quot; alt=&quot;GraphQL compared to REST for mobile&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h3 id=&quot;graphql-will-help-you-handle-complex-schemas&quot;&gt;GraphQL will help you handle complex schemas&lt;/h3&gt;

&lt;h4 id=&quot;for-user-interfaces&quot;&gt;For User Interfaces&lt;/h4&gt;

&lt;p&gt;Is your application based on a Schema using a lot of nested models and associations?&lt;/p&gt;

&lt;p&gt;Does your designer deliver a complex UI showing many resources all-in-one place?&lt;/p&gt;

&lt;p&gt;Since modern UI applications become more and more complex with rich user experience using data far away from the REST CRUD based API, GraphQL comes with a nice solution to Domain Driven APIs.&lt;/p&gt;

&lt;p&gt;By Domain Driven API, building APIs that exposes data schema dedicated to its usage (like computed values, flattened relations)&lt;/p&gt;

&lt;p&gt;Just take the following chat model example:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://honest.engineering/assets/chat-example-models.png&quot; alt=&quot;Example chat models&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Basically a chat can be:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;one-on-one conversation&lt;/li&gt;
  &lt;li&gt;group conversation&lt;/li&gt;
  &lt;li&gt;conversation around a post (images, videos or notes)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Let’s now consider the following associated UI mockup:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://honest.engineering/assets/chat-component-mockup.png&quot; alt=&quot;Example chat UI mockup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can now easily understand that developing and maintaining these kind of components, especially with realtime and paging can be hard with REST APIs since you will have to deal with many associations, up to 3 nesting levels.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://honest.engineering/assets/chat-models-with-chat-component.png&quot; alt=&quot;Example chat UI mockup with models&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;on-the-server-to-server-side&quot;&gt;On the server-to-server side&lt;/h4&gt;

&lt;p&gt;This example is also true on the “server to server” side.&lt;/p&gt;

&lt;p&gt;GraphQL is not a front-end client only, it can also be used on a server-to-server scenario.&lt;/p&gt;

&lt;p&gt;See the &lt;a href=&quot;http://git-awards.com/&quot;&gt;Github Awards&lt;/a&gt; website that ranks Github users by counting stars on their repos.&lt;/p&gt;

&lt;p&gt;This website has to fetch all users’ repos and count stars, which is totally feasible with REST.&lt;/p&gt;

&lt;p&gt;However, imagine that the maintainers want to update the ranking formula by using:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;user followers count&lt;/li&gt;
  &lt;li&gt;number of forks for all repos&lt;/li&gt;
  &lt;li&gt;include repos from organisations that users belongs to.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then, it will become hard to do with REST.&lt;/p&gt;

&lt;p&gt;Hopefully, Github is one of the rare company that provides a &lt;a href=&quot;https://developer.github.com/v4/&quot;&gt;public GraphQL endpoint&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Fetching all this data will be easy to do and maintain - without even talking about performance.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;This is one of the many “data synchronization” process that is easier to do with GraphQL.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h3 id=&quot;graphql-as-a-microservice-orchestration-solution&quot;&gt;GraphQL as a microservice orchestration solution&lt;/h3&gt;

&lt;p&gt;GraphQL, especially when used with Apollo Server, provides two killer features for orchestration.&lt;/p&gt;

&lt;p&gt;First, abstracting many REST APIs behind a unified - domain driven - GraphQL Schema.&lt;/p&gt;

&lt;p&gt;Apollo Server &lt;a href=&quot;https://www.apollographql.com/docs/apollo-server/features/data-sources.html#REST-Data-Source&quot;&gt;provides REST DataSource&lt;/a&gt; in order to implement REST API orchestration.&lt;/p&gt;

&lt;p&gt;You will, in a glance, be able to provide to a user-facing API, a unified and optimised public API of your microservices.&lt;/p&gt;

&lt;p&gt;This will allow you to have a better handling of versioning, maturity levels of your APIs through a decoupled architecture.&lt;/p&gt;

&lt;p&gt;Finally, take a look at schema stitching.&lt;/p&gt;

&lt;p&gt;Schema stitching is the process of creating a single GraphQL schema from multiple underlying GraphQL APIs.&lt;/p&gt;

&lt;p&gt;This feature, &lt;a href=&quot;https://www.apollographql.com/docs/graphql-tools/schema-stitching.html&quot;&gt;only available with Apollo Server&lt;/a&gt;, is similar to REST API abstractions.
However, the cool thing is that, by unifying many GraphQL APIs into one, Apollo will forward types for you, no need to reimplement all abstracted sources resolvers. 🚀&lt;/p&gt;

&lt;p&gt;When it comes to microservices orchestration, GraphQL provides you with two different and complete ways of providing the best architecture for your back-end.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h3 id=&quot;graphql-will-give-your-team-a-better-developer-experience&quot;&gt;GraphQL will give your team a better Developer Experience&lt;/h3&gt;

&lt;p&gt;If you need to remember one good reason to use GraphQL, stick to Developer Experience.&lt;/p&gt;

&lt;p&gt;GraphQL enhance your developers Experience in many ways, from the language to the ecosystem.&lt;/p&gt;

&lt;h4 id=&quot;descriptive-language-to-handle-complex-data&quot;&gt;Descriptive Language to handle complex data&lt;/h4&gt;
&lt;p&gt;You can feel that GraphQL is inspired from the JSON syntax, it makes this language easy to learn and understand and also easy to organise in the code (for example using dedicated files)&lt;/p&gt;

&lt;p&gt;Since your data requests are now expressed by a language, stored via strings, it becomes instantly understandable which data your code is manipulating.&lt;/p&gt;

&lt;h4 id=&quot;loading-state-management-simplified&quot;&gt;Loading state management simplified&lt;/h4&gt;

&lt;p&gt;Despite the fact that Apollo can be seen as the “Achilles’ heel” of GraphQL, this library bring exactly what you expect from a framework: more time to focus on the domain centric features, on the actual product.&lt;/p&gt;

&lt;p&gt;Apollo React will handle for you two main technical difficulties.&lt;/p&gt;

&lt;p&gt;Client-side caching by maintaining for you a cache of requested data and keep it updated using Observables.&lt;/p&gt;

&lt;p&gt;The nifty thing is the ability for Apollo to update related objects across many queries.&lt;/p&gt;

&lt;p&gt;The second problem-solved is the Query states mechanism provided by the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;Query&amp;gt;&lt;/code&gt; component.&lt;/p&gt;

&lt;p&gt;Apollo enables developers to specify a caching strategy (specific at each query component) and also provides the ability to view components with usefuls informations about the data (loading, state, error).&lt;/p&gt;

&lt;p&gt;This customisation and information allow to build fine-tuned components with great UX.&lt;/p&gt;

&lt;p&gt;At last word about Apollo will mention the ability to customise the default behaviour of Apollo by providing custom links, or even a custom cache implementation.&lt;/p&gt;

&lt;p&gt;Definitely worth taking a look!&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h4 id=&quot;your-are-manipulating-types&quot;&gt;Your are manipulating types&lt;/h4&gt;
&lt;p&gt;Finally, remember that REST exposes JSON data while GraphQL exposes types.
This subtlety creates all the difference when it comes to parse and sent data to an API.&lt;/p&gt;

&lt;p&gt;Since everything is typed in GraphQL, it allows Apollo React to validate data sent on the client side, before reaching the API.&lt;/p&gt;

&lt;p&gt;Finally, Apollo provides type generation tools for TypeScript, Flow and also Swift for mobile development.
This is an awesome feature because, if your clients use types provided by your API, then your clients business logic become safer (for example: compared to plain JS)&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;h3 id=&quot;pros&quot;&gt;Pros&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Helps providing a mobile first user experience&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since mobile apps have rich UIs and are used over slow networks, GraphQL will help you to load only the relevant data without killing the Developer Experience.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Helps you handle complex schema&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since modern UI applications become more and more complex with rich UX using data far away from the REST CRUD based API, GraphQL allows you to combine data from different sources.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Microservices orchestration solution&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GraphQL, especially with Apollo Server, provides many features to hide backend complexity from clients.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Give your team a better Developer Experience&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GraphQL is not just a new way to query data, it also enhances the way your team (front-mobile/back) will work together.&lt;/p&gt;

&lt;p&gt;GraphQL also facilitates the creation of great UX by making loading and dealing with data easier.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h3 id=&quot;cons&quot;&gt;Cons&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Using a technology based on its popularity is not enough&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since a technology solves one or many specific issues, popularity is never sufficient to validate a technology choice.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GraphQL will not solve all your performance issues out the box&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GraphQL isn’t a performance optimiser tool, you are still responsible to improve performance.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GraphQL is not REST and will not replace it&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GraphQL and REST are two different things and deserve their place in the web technologies world.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GraphQL won’t solve all your problems&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GraphQL will help you build rich mobile or web clients.&lt;/p&gt;

&lt;p&gt;It can also helps you to improve data related backend - like indexing jobs.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div style=&quot;text-align: right;&quot;&gt;
&lt;em&gt;
Honest Engineers.
&lt;/em&gt;
&lt;div&gt;
&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="Feedback" /><summary type="html">To be honest, GraphQL had its dose of hype the last months.</summary></entry></feed>